"""
@author:      Dylan Pare
@date:        03/30/2023
@name:        mask_class.py
@description: Make a generate class allowing for the construction of different masks based on 
different parameters. Also have a routine to combine all generated masks to produce a final mask
for distribution.
"""
# Import needed packages
from astropy.io import fits
import numpy as np
import glob
import os

class MaskClass:
	"""Class for making and combining various masks."""

	def __init__(self):
		"""Initialization function for MaskClass.
		Inputs:
		None
		Outputs:
		None
		"""
		print("Please specify which masks to use [Mark True to use, else leave blank]: ")
		#prompt_thresh = input("Do you want to update thresholds? [defaults: ncomps = 8, AIC = -360.0, PB = 0.5, rms = 3.0, chisq = 10.0, redchisq = 1.0, residstd = 1.0]: ")

		params = {'ncomps': False,\
			'AIC': False,\
			'PB': False,\
			'rms' : False,\
			'chisq' : False,\
			'redchisq' : False,\
			'residstd' : False}

		thresh = {'ncomps' : 8,\
			'AIC' : -360.0,\
			'PB' : 0.5,\
			'rms' : 3.0,\
			'chisq' : 10.0,\
			'redchisq' : 1.0,\
			'residstd' : 1.0}

		ncomps = input("ncomps: ")
		AIC = input("AIC: ")
		PB = input("PB: ")
		rms = input("rms: ")
		chisq = input('chisq: ')
		redchisq = input('redchisq: ')
		residstd = input('residstd: ')	
		
		if ncomps == "True":
			params.update({"ncomps" : True})
		if AIC == "True":
			params.update({"AIC" : True})
		if PB == "True":
			params.update({"PB" : True})
		if rms == "True":
			params.update({"rms" : True})
		if chisq == "True":
			params.update({"chisq" : True})
		if redchisq == "True":
			params.update({"redchisq" : True})
		if residstd == "True":
			params.update({"residstd" : True})

		print("Default threshold levels for the different parameters: ncomps = 8, AIC = -360.0, PB = 0.5, rms = 3.0, chisq = 10.0, residstd = 1.0 [all except for AIC and PB are placeholders]")
		
		parent = os.path.dirname(os.getcwd())
		data_dir = parent + '/HC3N_TP_7m_12m_feather/stage_4/'
		mask_dir = os.getcwd() + '/mask_dir/'
		decomps  = ['v0','v1','v2']

		self.params = params
		self.thresh = thresh
		self.data_dir = data_dir
		self.mask_dir = mask_dir
		self.decomps = decomps
		return

	def make_mask(self):
		"""Make a mask for each parameter flagged as True.
		Inputs:
		None
		Outputs:
		mask_list = aarray of the names for the individual masks generated
		"""
		v0_mlist = []
		v1_mlist = []
		v2_mlist = []
		value_list = list(self.thresh.values())
		do_mask    = list(self.params.values())
		key_list   = list(self.params.keys())
		for decomp in range(len(sorted(self.decomps))):
			for el in range(len(value_list)):
				if do_mask[el] == True:
					if key_list[el] != 'PB':
						print("Making mask based on " + key_list[el] + ' ' + self.decomps[decomp] + " threshold.")
						print('')
						data_name = self.data_dir + 'stage_4_' + key_list[el] + '.' + self.decomps[decomp] + '.refit.fits'
						data_im   = fits.open(data_name)[0].data
						cutoff = value_list[el]
						mask_name = key_list[el] + '_' + self.decomps[decomp] + '_mask.fits'
						mask_dat = np.zeros(data_im.shape)
						mask_head = fits.open(data_name)[0].header
						for ra in range(len(data_im)):
							for dec in range(len(data_im[0])):
								if data_im[ra][dec] <= cutoff:
									mask_dat[ra][dec] = 1
						fits.writeto(self.mask_dir + mask_name,data=mask_dat,header=mask_head,overwrite=True)
					else:
						print("Making mask based on " + key_list[el] + ' ' + self.decomps[decomp] + " threshold.")
						print('')
						data_name = self.data_dir + 'SgrB2_PB.fits'
						data_im = fits.open(data_name)[0].data
						cutoff = value_list[el]
						mask_name = key_list[el] + '_' + self.decomps[decomp] + '_mask.fits'
						mask_dat = np.zeros(data_im.shape)
						mask_head = fits.open(data_name)[0].header
						for ra in range(len(data_im)):
							for dec in range(len(data_im[0])):
								if (data_im[ra][dec] <= cutoff) or (np.isnan(data_im[ra][dec]) == True):
									mask_dat[ra][dec] = 1
						fits.writeto(self.mask_dir + mask_name,data=mask_dat,header=mask_head,overwrite=True)
					if decomp == 0:					
						v0_mlist.append(mask_name)
					elif decomp == 1:
						v1_mlist.append(mask_name)
					else:
						v2_mlist.append(mask_name)
		return v0_mlist, v1_mlist, v2_mlist

	def super_mask(self,v0_mlist,v1_mlist,v2_mlist):
		"""Create a super mask incorporating all of the sub-masks generated by the make_mask routine.
		Inputs:
		mask_list = array of string names referencing the sub-masks from make_mask.
		"""
		print("Making super masks based on mask parameters used.")
		mask_list = np.array([])
		for decomp in range(len(sorted(self.decomps))):
			if decomp == 0:
				mask_list = v0_mlist
			elif decomp == 1:
				mask_list = v1_mlist
			else:
				mask_list = v2_mlist

			# Iterate over the masks to create a super mask
			m_name = self.mask_dir + mask_list[0]
			m_shape = fits.open(m_name)[0].data
			super_mask = np.zeros(m_shape.shape)
			for mask in range(len(mask_list)):
				mask_name = self.mask_dir + mask_list[mask]
				mask_dat = fits.open(mask_name)[0].data
				mask_hdr = fits.open(mask_name)[0].header
				for ra in range(len(mask_dat)):
					for dec in range(len(mask_dat[0])):
						if super_mask[ra][dec] == 1:
							continue
						elif mask_dat[ra][dec] == 1:
							super_mask[ra][dec] = 1
				
			fits.writeto(self.mask_dir + 'super_' + self.decomps[decomp] + '_mask.fits',data=super_mask,header=mask_hdr,overwrite=True)
		return
